# 프로세스와 스레드

![Untitled](https://user-images.githubusercontent.com/119831581/227417160-88e48db7-3d87-4e10-af81-8dbc254c96a4.png)

### 프로세스(Process)

- 실행 프로그램, 현재 실행 중인 프로그램이다, 컴퓨터에 의해 작업이 완료되는 것들을 말한다
- 애플리케이션은 하나 이상의 프로세스로 구성되어있다
- 가상 주소 공간, 고유한 프로세스 식별자, 프로세스 스택, 레지스터, 프로그램 코드 등등 최소 하나의 실행 스레드가 들어있다
    - 프로세스를 집이라고 생각하자, 단순히 집만 있으면 아무것도 할 수가 없다
- 컴퓨터 프로그램이 실행되면 직접 실행되지 않고 프로그램 실행에 필요한 단계를 먼저 결정하고 이러한 실행 단계를 따르는 것이 프로세스이다
- 프로세스의 상태는 신규, 준비, 실행중, 대기중, 종료됨, 일시중지 상태가 있다
- 메인 프로세스에 의해 생성된 다른 프로세스를 자식 프로세스라고 한다
- **PCB**(Process Control Block)으로 공정 운영을 쉽게 제어할 수 있다
    - 프로세스 ID, 우선순위, 상태 및 내용 등 중요한 정보를 포함하는 프로세스의 두뇌

**속성**

- 각 프로세스를 생성하려면 해당 프로세스에 대해 별도의 시스템 호출이 필요하다
- 시스템 호출의 수를 크게 증가시키는 통신을 위해 IPC(Inter-Process Communication) 매커니즘을 사용한다

---

### 스레드(Thread)

- 프로세스의 일부인 실행 단위이다
- 스케줄러가 독립적으로 관리할 수 있는 가벼운 프로세스
    - 기본적으로 대규모 프로세스의 하위 부분들이다
- 하나의 프로그램은 하나의 스레드를 가지고 있다
- 실행을 예약할 수 있는 프로세스 내의 엔티티(Entity)이다

> 엔티티는 실제 객체라고 보면 된다
> 
- 스레드는 자신이 속한 프로세스 내에서 피어 메모리, 데이터 등 **리소스를 공유**한다
- 스레드의 상태는 실행중, 준비됨, 차단됨 세가지 상태가 있다
- 프로세스는 모두 동시에 실행되는 여러 스레드를 가질 수 있다

세 가지 방법으로 스레드 구현을 할 수 있다

1. **사용자 수준 스레드**(User-level threads)
    - 커널 영역의 상위에서 지원되고 사용자 레벨의 라이브러리를 통해 구현됨
        
        라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다
        
        동일한 메모리 영역에서 스레드가 생성 및 관리되기에 속도가 빠르지만,
        여러 개의 사용자 스레드중 하나가 중단되면 나머지 모든 스레드가 중단되는 단점이 있다
        
        커널이 프로세스 내부의 스레드를 인식하지 못하여 해당 프로세스를 대기 상태로 전환시키기 때문
        
        
2. **커널레벨 스레드**(Kernel-level threads)
    - 운영체제가 지원하는 스레드 기능으로 구현됨, 커널이 스레드의 생성 및 스케줄링 등을 관리
        
        스레드가 시스템 호출 등으로 중단되더라도 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다
        
        다만 사용자 스레드에 비해 생성 및 관리하는 것이 느림
        
3. Hybrid threads

**속성**

- 단일 시스템 호출은 둘 이상의 스레드를 생성할 수 있다
- 스레드 관리는 공유 메모리를 사용하여 달성할 수 있는 스레드간의 통신으로 인해  
매우 적은 수로 시스템을 호출 하거나 전혀 사용하지 않는다

---

### 프로세스와 스레드의 차이점

| 프로세스 | 스레드 |
| --- | --- |
| 프로그램이 실행중임을 의미함 | 프로세스의 세그먼트를 의미함 |
|  무겁다 | 가볍다 |
|  종료하는데 더 많은 시간이 걸린다 | 프로세스 보다 종료 시간이 덜 걸린다 |
| 생성에 더 많은 시간 | 생성에 더 적은 시간 |
| 프로세스간 통신은 스레드 보다 더 많은 시간이 필요함 | 스레드 간 통신은 프로세스에 비해 덜 걸림 |
| 컨텍스트 전환에 더 많은 시간이 걸림 | 컨텍스트 전환에 시간이 비교적 덜 걸림 |
| 리소스를 더 많이 사용함 | 리소스를 적게 사용함 |
| 다른 프로세스는 OS별로 별도로 진행됨 | 모든 수준의 피어 스레드는 OS에서 단일 작업으로 처리됨 |
| 각각 독립적인 메모리 사용 |  서로 메모리를 공유함 |
| 데이터를 공유하지 않음 | 서로 데이터를 공유함 |
| 스택, 메모리가 있는 힙 메모리, 데이터 맵이 있다 | 레지스터와 스택이 있다 / 명령,전역 및 힙 영역은 공유함 |
| 하나의 프로세스가 차단되면 다른 프로세스의 실행에 영향을 미치지 않는다 | 사용자 수준 스레드가 차단되면 다른 모든 사용자 수준 스레드도 차단된다 |

---

멀티 프로세스와 멀티스레드는 양쪽 모두 여러 흐름이 동시에 진행된다는 공통점을 가지고 있다

### 멀티 프로세스

멀티 프로세스에서 각 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지하고 있다

<br>

### 멀티 스레드

단일 스레드가 집에 혼자 사는 사람이라면, 멀티 스레드는 집에 여럿이 사는 형태인 가족과도 같다  
프로그램 환경에 따라 **둘 이상의 스레드를 동시에 실행**할 수 있는데 이러한 실행방식을 멀티스레드라고 한다  

모든 스레드는 동일한 프로세스에서 다른 스레드를 만들 수 있다  
생성 제한은 없지만 당연히 메모리 공간이 부족할 것이다  

멀티스레드는 CPU가 여러 개일 경우 각각의 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다  
→ 실제 시간상으로 동시에 수행될 수 있기 때문  

단점으로는 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다  
→ 원래 프로그램의 의도와 다르게 동작할 수 있음  
→ 스레드 실행 조건에 따라 결과가 다르게 나와 오류 발생 시 원인 찾기가 힘들다  
→ 이러한 상황을 **경쟁 상태(Race Condition)** 라고 한다  


![Untitled 1](https://user-images.githubusercontent.com/119831581/227417378-808794d6-a431-4423-86d1-275b90a46a8e.png)


<br>


### 경쟁 상태(Race Condition)

두 프로세스가 하나의 리소스에 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등에 의해 결과값이 달라질 수 있는 상태이다  
결과값이 항상 같지 않을 수 있기 때문에 자료의 일관성을 해치는 결과가 나올 수 있다  

스레드는 공유 메모리를 사용하기 때문에 동시성 문제가 일어날 수 있다  
이를 위해 공유 리소스에 대한 접근을 제어하기 위해 뮤텍스와 세마포어라는 매커니즘을 사용하고  
그 외에도 피터슨의 알고리즘, 데커의 알고리즘 등 상호 배제를 위한 프로그래밍 알고리즘이 있다  

<br>


### 임계 영역(critical section)

임계 영역은 한 번에 하나의 스레드에 의해서만 원자적으로 실행되어야 하는 코드 섹션이다   
내부 및 외부에서 변경되는 변수를 신중하게 다룰 수 있게 해당 자원에 동시 접근을 막는 것이다  
일반적으로 뮤텍스와 세마포어와 같은 동기화 메커니즘으로 보호되며   
이를 통해 한 번에 하나의 스레드만 임계 영역을 실행할 수 있도록 한다  

프린터와 같은 공유 리소스에 한번에 한 프로세스만 접근해서 작업을 수행해야하는 경우에 사용된다  


<br>


### 기아상태(Starvation)

스레드 기아상태는 다중 스레드 응용프로그램에서 스레드가 작업을 수행하는 데 필요한  
공유 리소스에 접근할 수 없을 때 발생하는 상태이다  

공유 리소스에 대한 여러 스레드가 접근하는 경쟁상태가 원인이기도 하지만  
비효율적이거나 불공평한 스케줄링 또는 메모리 누수에 의해서 발생하는 경우도 있다  

<br>


### 상호 배제(Mutual Exclusion), 뮤텍스(MuTex)

특정 자원에 대해 많은 스레드는 서로 상호 배타적이다  
한 집(프로세스)에 있는 가족 중 하나의 가족구성원(스레드 중 하나)이 화장실을 쓴다면 혼자 쓰고 싶을 것이다  
→ 이런 경우 화장실을 쓰는 사람이 들어가 문을 잠그고 볼일을 보고 나오면 다른 사람이 쓸 수 있게 된다  

이렇게 여러 스레드가 동시에 액세스하지 못하도록 **뮤텍스(MuTex)** 라는 매커니즘을 사용한다  
뮤텍스는 **잠금(lock)** 매커니즘이다  
→ 뮤텍스가 문의 잠금장치와 같은 것임, **lock** 을 건다  

스레드가 공유 리소스를 사용하게 되면서 잠금(lock)을 얻으면  
잠금을 소유한 스레드가 잠금해제(작업완료)를 할 때까지 다른 스레드가 잠금을 얻을 수 없다  
→ 가정집의 도어록처럼 잠금을 얻기위해 대기 중인 스레드는 일시중지된다   

일반적으로 공유 리소스에 액세스하고 원자적으로 실행되어야 하는 코드의 일부인 중요한 섹션을 보호하는데 사용된다  

<br>


### 세마포어(Semaphore)

대부분의 가정집에 주방이 있을 것이다  
세마포어는 집의 주방에 들어올 수 있는 사람의 수를 제한하고 싶을때 사용하는 방법이다  

세마포어도 멀티 스레드 환경에서 공유 리소스에 대한 액세스를 제어하고 싶을 때 사용되는 동기화(synchronized) 매커니즘이다  

뮤텍스 방식으로는 lock을 가진 단 한 명밖에 용인되지 않기에 한 명보다는 더 많은 사람으로 제한하고 싶을 때를 생각해보자  
여러 스레드들은 한번에 허용된 **세마포어의 개수** 만큼만 사용할 수 있다  

즉, 이 상황에서 스레드는 세마포어라는 티켓을 가지고 있어야만 자원을 사용할 수 있는 것이다  
다만 세마포어는 뮤텍스와 달리 소유권 개념이 없다  
때문에 교착 상태(deadlock) 복구라던가 특정한 컨텍스트에서 유용할 수 있다  

세마포어의 값이 1인 경우는 뮤텍스와 비슷한 이진 세마포어이고  
1보다 큰 값을 가진 세마포어는 카운팅 세마포어라고 불린다  

<br>


**카운트가 1인 세마포어(이진(binary) 세마포어)**

세마포어의 초기값이 0 또는 1만 가질 수 있는 세마포어  
뮤텍스와 이진 세마포어는 비슷해보이지만 같은 것은 아니니 주의하자  

<br>


- 그렇다면 둘의 차이는?
    
    
    뮤텍스를 특수 목적의 세마포어로 볼 수도 있다
    
    뮤텍스가 한번에 하나의 방에 들어가기 위한 키를 갖고 있는 것이라면 
    
    세마포어는 제한된 수의 인원이 동시에 방에 들어가기 위한 티켓과도 같다
    
    뮤텍스는 리소스에 대한 액세스를 동기화하는데 사용되는 **잠금 메커니즘**이다
    
    - 하나의 작업(스레드 또는 프로세스)만이 뮤텍스를 획득(소유권)할 수 있고 소유자만이 잠금을 해제할 수 있는 것!
    - 뮤텍스를 획득한 스레드만이 잠금을 풀 수 있는 점
    - 코드의 특정 부분에서 하나의 스레드를 실행하려는 경우 뮤텍스가 가장 효율적인 구현이다
    
    이진 세마포어는 **신호 메커니즘**이다
    
    - “완료되었습니다, 계속할 수 있습니다”와 같은 종류의 신호를 말한다
    - 다른 스레드/프로세스가 잠금을 해제할 수 있어 뮤텍스보다 빠르다
    
    결론적으로 구현이 유사한 것이지 완전히 똑같은 것은 아니라는 점이다
    
    참고 : 
    
    [Mutex vs Semaphore - GeeksforGeeks](https://www.geeksforgeeks.org/mutex-vs-semaphore/?ref=rp)
    

<br>


**카운트가 1보다 큰 세마포어(카운팅 세마포어)**

1보다 큰 값을 가질 수 있는 세마포어  
주방을 쓰고 싶은 사람을 4명, 5명, … n명까지 제한할 수 있다는 것이다  
→ 리소스에 대한 액세스 권한의 수를 1보다 크게 설정할 수 있는 것  

만약 값이 4인 상태에서 4개의 스레드가 사용중이고(세마포어 값이 0)  
거기서 추가로 하나의 스레드가 리소스를 더 쓰고 싶다면 세마포어 값이 양수가 될 때까지 기다려야한다  

자바 공식문서 - 세마포어 : 

[API reference for Java Platform, Standard Edition](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html)

<br>


**Synchronized (in java)**

기본적으로 하나의 프로세스 안에서 스레드는 공유하고 있는 자원을 사용한다  
이때 발생하는 문제가 스레드 간섭(interference) 및 메모리 일관성(consistency) 오류가 발생할 수 있는데  
이것을 방지하기 위해 동기화(synchronized) 키워드를 사용해서 해결할 수 있다  

synchronized method 를 사용하거나 메서드 안에 `synchronized(object)` 를 넣어 사용한다면  
공유된 자원을 항상 갱신하면서, 즉 동기화된 채로 사용할 수 있다  

메서드 반환타입 앞에 synchronized 키워드를 붙이거나 synchronized블록을 선언하기만 하면 되는 방식이라 사용하기는 정말 쉽다  

하지만 문제점이 몇 가지 있다  

1. 성능 오버헤드
    - 하나의 스레드만 동기화된 블록이나 메서드에 접근할 수 있어 불필요한 동기화 사용과 잠금과 잠금해제 활동에 비용이 증가해 애플리케이션 성능이 저하될 수 있다
2. 교착 상태 위험성
    - synchronized를 사용해도 여전히 교착상태 위험성이 남아있다
3. 공정성 보장 없음
    - 스레드가 요청한 순서대로 공유 리소스에 대한 액세스 권한이 부여된다는 보장이 없다  
      일부 스레드는 권한이 없을 수도 있고 그에 비해 다른 스레드는 더 자주 권한을 획득하는 상황이 발생할 수 있다    
4. 제한된 유연성
    - 단일 리소스에 대한 잠금만 허용한다, 다른 복잡한 동기화 시나리오에는 적합하지 않다

<br>


### 스레드 우선순위

많은 사람들(스레드)이 사용하고자 하는 자원(화장실)을 이용하려고 한다면 누가 먼저 이용해야 하는지 어떻게 정할까?  

**우선 순위**와 **대기 시간**이라는 두 가지 요소로 해결할 수 있다  

두 사람이 동시에 화장실을 이용한다고 했을 때   
→ 첫 번째 사람은 출근시간 혹은 마감시간이 촉박한 상태고  
→ 두 번째 사람은 느긋하고 여유로운 상태이다  

이런 경우 두 번째 보다 첫 번째 사람에게 화장실을 먼저 쓰게하는 것이 합리적인 판단이다  

첫 번째 사람에게 더 높은 우선순위를 할당하면 되는 것이다  
많은 스레드가 대기중이고 잠금이 풀렸다면 **우선순위가 가장 높은 스레드에 권한을 제공**할 것이다  

만약 우선순위 권한이 동일하다면 대기 시간에 따라 구분지을 수 있을 것이다  
다만 대기 시간이 우선순위에만 영향을 받는 것은 아니다  
시스템의 스레드 수, 애플리케이션 복잡성 등 다른 요소도 영향을 줄 수 있다  

<br>


### **교착 상태(deadlock)**

데드락이라고도 하며 두 개 이상의 스레드가 서로를 기다리고 있는 상황일 때 교착상태가 발생한다  
![220px-Two_processes_two_resources](https://user-images.githubusercontent.com/119831581/227418535-e2b0ff41-d54e-4f62-a3db-70a2674d8184.gif)
![Deadlock_at_a_four-way-stop](https://user-images.githubusercontent.com/119831581/227418554-e87fa665-f84b-44dd-8faf-3bbc22c7f9b4.gif)



간단히 상황으로 설명하자면  

Thread1은 A를 가지고 있고 B를 기다리는 중이다  
Thread2는 B를 가지고 있고 A를 기다리는 중이다  

따라서 서로 잠금(lock)을 가지고 있고 각자에게 필요한 잠금이 풀릴때까지 아무것도 하지않아 진행할 수 없는 상황인 것이다  

<br>


### 컨텍스트 스위칭(context switching)

작업하는 도중에 다른 프로세스로 CPU를 전환하는 과정이다  
운영체제가 한 프로세스의 실행을 일시 중지하고 다른 프로세스의 실행을 재개하는 매커니즘이다  

컨텍스트 스위칭이 일어났을 때 PCB(Process Control Block)에는 프로그램 카운터, 프로세서 레지스터 및 기타 데이터를 포함한 현재 스레드의 실행 상태를 저장하게 된다  
그런 다음 운영체제는 이전에 저장했던 상태를 로드해서 불러와 실행을 재개한다  

스레드 풀 사이즈가 늘어나면 컨텍스트 스위칭의 빈도수는 더 늘어난다  
코어가 4개이고 스레드 풀 사이즈가 8개 → 16개로 되었다면  

8개인 경우 8/4 → 2번  
16개인 경우 16/4 → 4번이 된다  

스레드에서의 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭 보다 빠른데  
스레드는 서로 공유하는 자원이 있어서 이전에 했던 작업을 복원하는데 시간이 얼마 걸리지 않기 때문이다  
반대로 프로세스의 경우 다른 프로세스로 바꾸는 상황이라면 메모리 주소가 다르기 때문에   
캐시도 비워야 하고 [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)도 비워야 하는 작업이 추가되어 더 오래 걸린다  

<br>


### 스레드 원자(atomic)성

공유된 가변 상태는 동시성이 수반될때 매우 쉽게 문제가 발생한다  
잠금(lock)을 사용하여 문제를 해결해도 성능에 타격이 간다  
스레드를 일시 중지했다가 다시 시작하는 프로세스는 비용이 많이 들기 때문이다  

이렇게 다중 스레드 프로그램인 경우 명시적 동기화를 줄이기 위해 원자성 작업을 사용하면 성능을 향상시킬 수 있다 ex) `AtomicInteger`, `AtomicLong` , `AtomicReference`  
동시성 문제를 해결해야할 때 Atomic 클래스를 사용하기도 한다  

하지만 원자성 작업이 개별 변수에 대해 안전한 스레드 접근성만 제공하고  
여러 변수 또는 작업간의 동기화를 제공하지 않는다는 점이 있다  


<br>


### 스레드 풀(Thread Pool)

![400px-Thread_pool svg](https://user-images.githubusercontent.com/119831581/227418791-37d31bb0-b0bc-4422-9eae-bec9d73f05b7.png)

![kknmh48t](https://user-images.githubusercontent.com/119831581/227418814-723124fe-3870-43f4-8b1f-ad978c6be36f.png)  

스레드 풀은 컴퓨터 프로그램에서 동시 실행을 달성하기 위한 소프트웨어 설계 패턴이다  

스레드를 한 두번 사용하고 반납하는 상황이라면 개별적으로 thread 인스턴스를 만들어도 상관없겠지만, 서버 애플리케이션의 경우 수많은 thread가 필요하고 초 단위로 thread의 생성과 반납이 이루어져야한다  
자바에선 start() 메서드 호출 시 커널 스레드를 할당받아 사용한다  

그러나 커널 스레드는 꽤 비싼 연산이고 이것을 초 단위로 수백번 이상의 연산이 이루어지면  
메모리 부족 현상이 오기 마련이다  

심지어 반납한 thread의 인스턴스를 메모리에서 해제하는 일도 있어 GC도 바빠지기에 CPU의 일이 증가한다  

그래서 생성과 메모리 해제 비용을 줄이기 위해  
thread를 미리 생성해 놓고 필요할 때만 가져다가 사용한다음  
커널 스레드를 **반납하지 않고 재사용**할 수 있도록 하는 Thread Pool이 만들어졌다   

스레드 수는 대기 작업 수에 따라 응용 프로그램 수명 동안 동적으로 조정될 수 있다  

웹 서버의 경우 수많은 웹페이지 요청이 들어오면 스레드를 추가할 수 있고  
요청이 줄어들면 스레드를 제거할 수 있다  

수동으로 스레드를 생성하는 것에 비해 재사용성, 스레드 수 제어, 로드밸런싱 등의 이점이 있다  

<br>


참조 : 

[Processes and Threads](https://www.qnx.com/developers/docs/6.5.0SP1.update/com.qnx.doc.neutrino_getting_started/s1_procs.html#Threads_and_processes)

[스레드 (컴퓨팅)](https://ko.wikipedia.org/wiki/스레드_(컴퓨팅))

[Difference between Process and Thread - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-process-and-thread/?ref=gcse)

[Process vs Thread – Difference Between Them](https://www.guru99.com/difference-between-process-and-thread.html)

<br>


스레드 풀

[[자바 무료 강의] Thread Pool](https://www.codelatte.io/courses/java_programming_basic/7S5AANE0DS9VHQR8)

<br>


동시성

[Lesson: Concurrency (The Java™ Tutorials > Essential Java Classes)](https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html)

<br>


세마포어 

[Semaphore (Java Platform SE 7 )](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html)

<br>


교착 상태(데드락)

[Deadlock](https://en.wikipedia.org/wiki/Deadlock)
